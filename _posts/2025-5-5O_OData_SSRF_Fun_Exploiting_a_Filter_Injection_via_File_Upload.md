---
title: "OData + SSRF = Fun: Filter Injection via File Upload"
published: true
layout: post
categories: [bounty]
tags: [bounty, OData, injection, SSRF, IDOR, enumeration]
---

## Introduction

Assalamu Alaikum! I‚Äôm Nasur Ullah  an OSCP-certified penetration tester from Pakistan with a strong interest in web application security and bug bounties.

In this write-up, I‚Äôll walk you through how I discovered a **filter injection vulnerability in an OData-powered API** that allowed user enumeration, and later discovered **SSRF-like behavior** using the same endpoint. While the bug wasn't directly RCE or P1, the flexibility and depth of this attack vector definitely made it interesting.

---

## What is OData?

OData (Open Data Protocol) is a REST-based protocol developed by Microsoft to enable CRUD operations (Create, Read, Update, Delete) on data using web services.

Think of it like SQL for REST APIs.

Some common query patterns include:

- `$filter`: Apply filters to entities  
- `$select`: Return only specific properties  
- `$expand`: Get related entities  
- `$orderby`, `$top`, `$skip`, etc.

For example:
```
GET /odata/Users?$filter=startswith(Name,'admin')&$select=Name,Email
```
Is similar to:
```sql
SELECT Name, Email FROM Users WHERE Name LIKE 'admin%'
```

You can learn more from [OData.org](https://www.odata.org/) or [Microsoft's docs](https://learn.microsoft.com/en-us/odata/).

---

## How I Found the Endpoint

During a black-box assessment, I was exploring a feature called **‚ÄúName Screening‚Äù** inside a document submission flow. After uploading a document, the frontend triggered a backend request with this interesting header:

```
X-Proxy-Destination: /gateway/api/users?$filter=IdentityId eq 'abc-123'
```

This header was sent by the browser and accepted by the backend to query internal APIs. Classic proxy header misuse. I immediately knew this was worth digging into.

---

## Exploiting OData Filter Injection

I intercepted the request in Burp Suite and tried replacing the filter with:

```
$filter=startswith(Name,'a') or true&$select=Name,Username
```

The server replied with a full list of users including usernames and emails:

- admin@redacted.com
- manager@redacted.com
- random phone-number usernames

All while using a **low-privileged account**.

![User Enumeration](/assets/OData/info.png)

At this point, I realized this was an **OData filter injection** vulnerability  and a good one.

---

## SSRF-Like Behavior via Header Injection

Things got more fun when I realized the `X-Proxy-Destination` value wasn't sanitized at all. What if I gave it a full URL?

```
X-Proxy-Destination: http://127.0.0.1:80
```

The server responded with what looked like the root page of localhost!

![SSRF Localhost](/assets/OData/localhost.png)

To confirm, I generated a **Burp Collaborator** URL and sent:

```
X-Proxy-Destination: http://<collab>.burpcollaborator.net
```

And sure enough  a **DNS ping** came through. So the backend actually reached out to arbitrary URLs controlled by the user.

![Burp Ping](/assets/OData/burp.png)

This hinted at a **server-side request forgery (SSRF)** vulnerability  not always exploitable to RCE, but enough to:

- Access internal services
- Exfiltrate data
- Check for open ports or internal metadata

---

## Step-by-Step Exploitation Flow

1. Login as a normal user.
2. Navigate to the form submission flow and choose "Name Screening."
3. Upload a file and intercept the request.
4. Observe the `X-Proxy-Destination` header containing OData `$filter` query.
5. Replace the filter with:
   ```
   $filter=startswith(Name,'a') or true&$select=Name,Username
   ```
6. Confirm user enumeration.
7. Modify the header to `http://127.0.0.1:80` and observe local SSRF response.
8. Send a Burp Collaborator URL and confirm DNS lookup.

---

## Impact Summary

- **Unauthorized Access**: Enumerate all usernames and emails via OData queries
- **SSRF Behavior**: Abuse proxy header to access internal services
- **Information Disclosure**: Harvest internal data, admins, user patterns
- **Possible Privilege Escalation or Chaining**: Combine with IDORs or reset flows

---

## Suggested Fixes

- Disable untrusted header forwarding like `X-Proxy-Destination`
- Validate and sanitize OData queries server-side
- Disallow unfiltered use of `$filter`, `$select`, `or`, `startswith`
- Add SSRF protections (block localhost, internal ranges)
- Implement allowlisting for internal services

---

## Final Thoughts

This bug is a great example of how:
- A small detail like a custom header can expose large functionality
- OData, while powerful, can lead to complex attack vectors if misused
- SSRF isn't just in parameters  it can hide in headers too

I hope you enjoyed this journey! See you in the next write-up üëã

Happy hacking and always disclose responsibly.
